<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Correlation Power Analysis in PicoCTF 2023 | Jacob&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Table of Contents
Introduction Solving the Challenge Additional Thoughts Conclusion Introduction The hardest and also most interesting cryptography challenge of PicoCTF 2023 involved undoing AES using a side channel attack, specifically power analysis.
If I&rsquo;m going to be honest, it was a pretty big surprise to see a side channel attack be the primary challenge within Pico but it was definitely a fun experience.
Solving the Challenge The core idea of correlation power analysis (CPA) is to take the non-linear part of AES, the S-box lookup and use that bit of info to extract more information about the key.">
<meta name="author" content="">
<link rel="canonical" href="https://jacob-rc.github.io/posts/correlation-power-analysis-in-pico-ctf-2023/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jacob-rc.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jacob-rc.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jacob-rc.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jacob-rc.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jacob-rc.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Correlation Power Analysis in PicoCTF 2023" />
<meta property="og:description" content="Table of Contents
Introduction Solving the Challenge Additional Thoughts Conclusion Introduction The hardest and also most interesting cryptography challenge of PicoCTF 2023 involved undoing AES using a side channel attack, specifically power analysis.
If I&rsquo;m going to be honest, it was a pretty big surprise to see a side channel attack be the primary challenge within Pico but it was definitely a fun experience.
Solving the Challenge The core idea of correlation power analysis (CPA) is to take the non-linear part of AES, the S-box lookup and use that bit of info to extract more information about the key." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jacob-rc.github.io/posts/correlation-power-analysis-in-pico-ctf-2023/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-26T19:57:03-07:00" />
<meta property="article:modified_time" content="2023-06-26T19:57:03-07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Correlation Power Analysis in PicoCTF 2023"/>
<meta name="twitter:description" content="Table of Contents
Introduction Solving the Challenge Additional Thoughts Conclusion Introduction The hardest and also most interesting cryptography challenge of PicoCTF 2023 involved undoing AES using a side channel attack, specifically power analysis.
If I&rsquo;m going to be honest, it was a pretty big surprise to see a side channel attack be the primary challenge within Pico but it was definitely a fun experience.
Solving the Challenge The core idea of correlation power analysis (CPA) is to take the non-linear part of AES, the S-box lookup and use that bit of info to extract more information about the key."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jacob-rc.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Correlation Power Analysis in PicoCTF 2023",
      "item": "https://jacob-rc.github.io/posts/correlation-power-analysis-in-pico-ctf-2023/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Correlation Power Analysis in PicoCTF 2023",
  "name": "Correlation Power Analysis in PicoCTF 2023",
  "description": "Table of Contents\nIntroduction Solving the Challenge Additional Thoughts Conclusion Introduction The hardest and also most interesting cryptography challenge of PicoCTF 2023 involved undoing AES using a side channel attack, specifically power analysis.\nIf I\u0026rsquo;m going to be honest, it was a pretty big surprise to see a side channel attack be the primary challenge within Pico but it was definitely a fun experience.\nSolving the Challenge The core idea of correlation power analysis (CPA) is to take the non-linear part of AES, the S-box lookup and use that bit of info to extract more information about the key.",
  "keywords": [
    
  ],
  "articleBody": "Table of Contents\nIntroduction Solving the Challenge Additional Thoughts Conclusion Introduction The hardest and also most interesting cryptography challenge of PicoCTF 2023 involved undoing AES using a side channel attack, specifically power analysis.\nIf I’m going to be honest, it was a pretty big surprise to see a side channel attack be the primary challenge within Pico but it was definitely a fun experience.\nSolving the Challenge The core idea of correlation power analysis (CPA) is to take the non-linear part of AES, the S-box lookup and use that bit of info to extract more information about the key.\nIn this writeup, I’m going to explain the process for solving power analysis 2 as the code and logic can be applied to power analysis 1 and warmup.\nIn AES’s operation, the key is first Xor-ed with the plain text, the result is then searched up in a S-box for substitution. The power analysis attack relies on the fact that the hamming weight (the number of ones within any binary number) can be correlated with the power consumption of a device which allows us to find the key.\nSince we’re given the specific power traces, we can run through various iterations of potential keys and see which keys when Xor-ed with the given plain text would generate the described power traces.\nFrom there it just becomes a matter of letting the program run until a key is generated that has a positive correlation with the power traces.\nHere’s the main resource my team and I used to first tackle this problem. https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/\nThis ended up being our team’s solve script (written by Nullawe)\nimport numpy as np import random, sys, time HW = [bin(n).count(\"1\") for n in range(0,256)] sbox=( 0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, 0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, 0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, 0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, 0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, 0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, 0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, 0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, 0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, 0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, 0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, 0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, 0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, 0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, 0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, 0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16) def intermediate(pt, keyguess): return sbox[pt ^ keyguess] traces = [] pt = [] for i in range(100): s = str(i) f = open(\"trace\" + s + \".txt\", \"r\") pt.append(bytes.fromhex(f.readline())) arr = [] strs = f.readline()[81:-2].split(\", \") for num in strs: arr.append(int(num)) traces.append(arr) f.close() print(len(traces[0])) print(len(pt[0])) bestguess = [] if bestguess == []: numtraces = np.shape(traces)[0]-1 numpoint = np.shape(traces)[1] bestguess = [0]*16 for bnum in range(0, 16): print(\"here bnum = \" + str(bnum)) cpaoutput = [0]*256 maxcpa = [0]*256 for kguess in range(0, 256): if (kguess % 10 == 0): print(\"here kguess = \" + str(kguess)) #Initialize arrays \u0026 variables to zero sumnum = np.zeros(numpoint) sumden1 = np.zeros(numpoint) sumden2 = np.zeros(numpoint) hyp = np.zeros(numtraces) for tnum in range(0, numtraces): hyp[tnum] = HW[intermediate(pt[tnum][bnum], kguess)] #Mean of hypothesis meanh = np.mean(hyp, dtype=np.float64) #Mean of all points in trace meant = np.mean(traces, axis=0, dtype=np.float64) #For each trace, do the following for tnum in range(0, numtraces): hdiff = (hyp[tnum] - meanh) tdiff = traces[tnum] - meant sumnum = sumnum + (hdiff*tdiff) sumden1 = sumden1 + hdiff*hdiff sumden2 = sumden2 + tdiff*tdiff cpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 ) maxcpa[kguess] = max(abs(cpaoutput[kguess])) bestguess[bnum] = np.argmax(maxcpa) key = '' for b in bestguess: key += \"%02x\"%b Additional Thoughts I feel it’s important to note that correlation power analysis doesn’t work in most circumstances. Looking at the power traces only works if and only if the device preforming encryption isn’t doing anything else. For example if the device was like your typical computer which was also doing calculations, those other actions would also influence the power consumption, rendering the power traces un-usable.\nCompared to other challenges, CPA didn’t have the most existing documentation, but of the resources that existed, they were quite helpful. In my opinion, a little too helpful. We were able to solve the challenge by using existing scripts and briefly changing the input method to follow Pico’s format. I do feel that the 300, 400 and 500 point challenges in pico shouldn’t be that simple to solve, especially with challenges like msfrog and cancri-sp.\nConclusion Overall a fun and very interesting challenge to see. I’m glad it wasn’t too mathy like many complex cryptography challenges tend to devolve into.\nThanks for reading and I hope you found something interesting.\n",
  "wordCount" : "680",
  "inLanguage": "en",
  "datePublished": "2023-06-26T19:57:03-07:00",
  "dateModified": "2023-06-26T19:57:03-07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jacob-rc.github.io/posts/correlation-power-analysis-in-pico-ctf-2023/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jacob's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jacob-rc.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jacob-rc.github.io/" accesskey="h" title="Jacob&#39;s Blog (Alt + H)">Jacob&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jacob-rc.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://jacob-rc.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Correlation Power Analysis in PicoCTF 2023
    </h1>
    <div class="post-meta"><span title='2023-06-26 19:57:03 -0700 PDT'>June 26, 2023</span>&nbsp;·&nbsp;4 min

</div>
  </header> 
  <div class="post-content"><p>Table of Contents</p>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#solving-the-challenge">Solving the Challenge</a></li>
<li><a href="#additional-thoughts">Additional Thoughts</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>The hardest and also most interesting cryptography challenge of PicoCTF 2023 involved undoing AES using a side channel attack, specifically power analysis.</p>
<p>If I&rsquo;m going to be honest, it was a pretty big surprise to see a side channel attack be the primary challenge within Pico but it was definitely a fun experience.</p>
<h1 id="solving-the-challenge">Solving the Challenge<a hidden class="anchor" aria-hidden="true" href="#solving-the-challenge">#</a></h1>
<p>The core idea of correlation power analysis (CPA) is to take the non-linear part of AES, the S-box lookup and use that bit of info to extract more information about the key.</p>
<p>In this writeup, I’m going to explain the process for solving power analysis 2 as the code and logic can be applied to power analysis 1 and warmup.</p>
<p>In AES’s operation, the key is first Xor-ed with the plain text, the result is then searched up in a S-box for substitution. The power analysis attack relies on the fact that the hamming weight (the number of ones within any binary number) can be correlated with the power consumption of a device which allows us to find the key.</p>
<p>Since we’re given the specific power traces, we can run through various iterations of potential keys and see which keys when Xor-ed with the given plain text would generate the described power traces.</p>
<p>From there it just becomes a matter of letting the program run until a key is generated that has a positive correlation with the power traces.</p>
<p>Here’s the main resource my team and I used to first tackle this problem.
<a href="https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/">https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/</a></p>
<p>This ended up being our team&rsquo;s solve script (written by Nullawe)</p>
<pre tabindex="0"><code>import numpy as np
import random, sys, time

HW = [bin(n).count(&#34;1&#34;) for n in range(0,256)]

sbox=(
0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16)

def intermediate(pt, keyguess):
    return sbox[pt ^ keyguess]

traces = []
pt = []

for i in range(100):
    s = str(i)
    f = open(&#34;trace&#34; + s + &#34;.txt&#34;, &#34;r&#34;)
    pt.append(bytes.fromhex(f.readline()))
    arr = []
    strs = f.readline()[81:-2].split(&#34;, &#34;)
    for num in strs:
        arr.append(int(num))
    traces.append(arr)
    f.close()

print(len(traces[0]))
print(len(pt[0]))

bestguess = []
if bestguess == []:

    numtraces = np.shape(traces)[0]-1
    numpoint = np.shape(traces)[1]

    bestguess = [0]*16
    
    for bnum in range(0, 16):
        print(&#34;here bnum = &#34; + str(bnum))
        cpaoutput = [0]*256
        maxcpa = [0]*256
        for kguess in range(0, 256):
            if (kguess % 10 == 0):
                print(&#34;here kguess = &#34; + str(kguess))
            #Initialize arrays &amp; variables to zero
            sumnum = np.zeros(numpoint)
            sumden1 = np.zeros(numpoint)
            sumden2 = np.zeros(numpoint)

            hyp = np.zeros(numtraces)
            for tnum in range(0, numtraces):
                hyp[tnum] = HW[intermediate(pt[tnum][bnum], kguess)]


            #Mean of hypothesis
            meanh = np.mean(hyp, dtype=np.float64)

            #Mean of all points in trace
            meant = np.mean(traces, axis=0, dtype=np.float64)

            #For each trace, do the following
            for tnum in range(0, numtraces):
                hdiff = (hyp[tnum] - meanh)
                tdiff = traces[tnum] - meant

                sumnum = sumnum + (hdiff*tdiff)
                sumden1 = sumden1 + hdiff*hdiff 
                sumden2 = sumden2 + tdiff*tdiff

            cpaoutput[kguess] = sumnum / np.sqrt( sumden1 * sumden2 )
            maxcpa[kguess] = max(abs(cpaoutput[kguess]))


        bestguess[bnum] = np.argmax(maxcpa)

    key = &#39;&#39;
    for b in bestguess: 
        key += &#34;%02x&#34;%b
</code></pre><h1 id="additional-thoughts">Additional Thoughts<a hidden class="anchor" aria-hidden="true" href="#additional-thoughts">#</a></h1>
<p>I feel it&rsquo;s important to note that correlation power analysis doesn&rsquo;t work in most circumstances. Looking at the power traces only works if and only if the device preforming encryption isn&rsquo;t doing anything else. For example if the device was like your typical computer which was also doing calculations, those other actions would also influence the power consumption, rendering the power traces un-usable.</p>
<p>Compared to other challenges, CPA didn&rsquo;t have the most existing documentation, but of the resources that existed, they were quite helpful. In my opinion, a little too helpful. We were able to solve the challenge by using existing scripts and briefly changing the input method to follow Pico&rsquo;s format. I do feel that the 300, 400 and 500 point challenges in  pico shouldn&rsquo;t be that simple to solve, especially with challenges like msfrog and cancri-sp.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Overall a fun and very interesting challenge to see. I&rsquo;m glad it wasn&rsquo;t too mathy like many complex cryptography challenges tend to devolve into.</p>
<p>Thanks for reading and I hope you found something interesting.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jacob-rc.github.io/">Jacob&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
